
///////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2021, Perry L Miller IV
//  All rights reserved.
//  MIT License: https://opensource.org/licenses/mit-license.html
//
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//
//  The root of the tree that gets rendered.
//
///////////////////////////////////////////////////////////////////////////////

#include "GSG/Tools/Tree/Root.h"

#include "Usul/Tools/NoThrow.h"

#include <functional>


namespace GSG {
namespace Tools {
namespace Tree {


// Add the boilerplate code.
GSG_IMPLEMENT_OBJECT_CLASS ( Root )


///////////////////////////////////////////////////////////////////////////////
//
//  Constructor.
//
///////////////////////////////////////////////////////////////////////////////

Root::Root() : BaseClass(),
  _layers()
{
}


///////////////////////////////////////////////////////////////////////////////
//
//  Destructor.
//
///////////////////////////////////////////////////////////////////////////////

Root::~Root()
{
  USUL_TOOLS_NO_THROW ( 1626111562, std::bind ( &Root::_destroyRoot, this ) );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Destroy this instance.
//
///////////////////////////////////////////////////////////////////////////////

void Root::_destroyRoot()
{
  _layers.clear();
}


///////////////////////////////////////////////////////////////////////////////
//
//  Clear the layers.
//
///////////////////////////////////////////////////////////////////////////////

void Root::clear()
{
  _layers.clear();
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the layer. Make it if we have to.
//
///////////////////////////////////////////////////////////////////////////////

Layer *Root::getLayer ( int key )
{
  // Look for the layer.
  Layers::iterator i = _layers.find ( key );

  // If we found it then return it.
  if ( _layers.end() != i )
  {
    Layer::ValidAccessRefPtr &existing = i->second;
    return existing.get();
  }

  // If we get to here then make it.
  Layer::RefPtr newLayer = new Layer;

  // Add it to our collection.
  _layers.insert ( Layers::value_type ( key, newLayer ) );

  // Return the new layer.
  return newLayer.get();
}


} // namespace Tree
} // namespace Tools
} // namespace GSG
